#include <stdio.h>
#include "suites.h"
#include "moreinttypes/utils.h"

/* https://stackoverflow.com/a/7120740 */
#if !(defined(_MSC_VER) || defined(VALGRIND))
#define HAVE_LONG_DOUBLE
#endif

START_TEST(ParseIntFromBinaryString)
{
    const int parsed = parse_int("10101010", 2);
    ck_assert_int_eq(170, parsed);
}

START_TEST(ParseIntFromOctalString)
{
    const int parsed = parse_int("252", 8);
    ck_assert_int_eq(170, parsed);
}

START_TEST(ParseIntFromDecimalString)
{
    const int parsed = parse_int("170", 10);
    ck_assert_int_eq(170, parsed);
}

START_TEST(ParseIntFromHexString)
{
    const int parsed = parse_int("Aa", 16);
    ck_assert_int_eq(170, parsed);
}

START_TEST(ParseInt64FromHexString)
{
    const uint64_t value = 0xFFFFFFFFFFFFFFF;
    const uint64_t parsed = MATCH_ARCH(parse_int)("FFFFFFFFFFFFFFF", 16);
    ck_assert_msg(value == parsed, "USE_64_BITS should be defined!");
}

START_TEST(ParseIntValidatesInput)
{
    const int parsed = parse_int("", 2);
    ck_assert_int_eq(0, parsed);
}

START_TEST(ParseIntValidatesBase)
{
    const int parsed = parse_int("abcd", 10);
    ck_assert_int_eq(0, parsed);
}

START_TEST(ParseIntChecksBounds)
{
    const uint64_t value = 0;
    const uint64_t parsed =
        MATCH_ARCH(parse_int)("FFFFFFFFFFFFFFFFFFFFFFFF", 16);
    ck_assert(value == parsed);
}

START_TEST(FactorialOfZero)
{
    const long double f = factorial_of(0);
    ck_assert_ldouble_eq_tol(1.0L, f, 0.1L);
}

START_TEST(FactorialOfSix)
{
    const long double f = factorial_of(6);
    ck_assert_ldouble_eq_tol(720.0L, f, 0.1L);
}

#ifndef VALGRIND
START_TEST(FactorialOfChecksBounds)
{
    const long double f = MATCH_ARCH(factorial_of)(0x1000);
    ck_assert_ldouble_eq_tol(0.0L, f, 0.1L);
}

START_TEST(FactorialOfChecksBoundsGivenNegativeInput)
{
    const long double f = factorial_of(-1);
    ck_assert_ldouble_eq_tol(0.0L, f, 0.1L);
}

START_TEST(FactorialOf64ChecksBoundsGivenNegativeInput)
{
    const long double f = factorial_of_64(-1);
    ck_assert_ldouble_eq_tol(0.0L, f, 0.1L);
}
#endif /* !VALGRIND */

#ifdef HAVE_LONG_DOUBLE
START_TEST(FactorialOf170)
{
    const char* value =
        "7257415615307998964955965095451627218788030796485756987610814761435430"
        "4032203000092562759553945544909364896218342898119758357683152362864404"
        "7752419726689407394349778788471523324527373471412274801370200536059197"
        "3100433273922458354834163910515297271113307287253169560774338881425893"
        "093276062890708813790314496";
    const long double result = MATCH_ARCH(factorial_of)(170);
    char szResult[512] = { 0 };
    snprintf(szResult, 512, "%.0Lf", result);
    ck_assert_str_eq(value, szResult);
}

START_TEST(FactorialOf1754)
{
    const char* value =
        "1979261890105010055285037090156832449109147659845547453334913812144794"
        "4050325455850220281751827991384731053649988146087506707500713316118450"
        "2974635426269671776773173832120581379828244911141712726753259253850912"
        "9134834467497920053099391536512053799703778811597215135036501690481649"
        "9136885828794831985778358219533899724906196428924462793239208373259569"
        "9806664919419484916885311578075617241108516527393043341360045911998919"
        "7880696745633198249564053417461352673891032304474452328181035966292414"
        "0161968085802174927702027366144023962261879724957022413921518821003624"
        "0086954031982234084285737884933286603044256828415586748294414372917325"
        "1578918640299139716320389714116033697834559924349824936403965885581779"
        "9979632528308994450886197814548433145091251578381565049749658112815806"
        "6897582237152903656384924919927350965655469432139027989192726490289178"
        "7453800132810516644189968324106050244544011369428232224458405099221482"
        "9266737568265565147130952913069765264311603420219853097231644370301875"
        "1996243596660037710977860484939886490185610614226510106422241107592420"
        "6289627069512363759165925307970179347916364148586908583007620441800015"
        "4341720940406976446204231289088236363114711048038756369547511693735325"
        "3671287200146557169485618767513809505397704594734398108430310051351876"
        "2946854626080401090177104327252775048628855005658792699214110860060904"
        "8080682349545223363550668549969826968411197526095024141458631963384517"
        "1178169444181672722237560486329044147884401688849777262549715133847010"
        "8302772169660124086865834993468102445391613905553317382828097507216125"
        "0230678766722735688960104944143588847089750300743671668207755677938523"
        "1179363545628397433923364822081937248813352153089061114419341266088449"
        "8031508660641492364973020590715608632952840178069109693942968963808090"
        "1430342438319489153495975524475787861753289610093111203190783015121956"
        "6607410047850465708254633689199844201320113673315595843221770739391083"
        "8319533475797942303489278469907707175068303828944249618925281040851142"
        "6468756566092232682212947623213890008449024670383417296700912399278859"
        "5165976099848330703110951864775667808477485980988876231942073770349794"
        "8383286519798417531936720016423077588187212555807180220060558662489703"
        "7870168402192750354683901371167954338441233101412391016861928006819024"
        "3168695062132234410368496350650829938826847017808774149224535686097526"
        "7489366500318854015717703729615072462066235135194354105519425704315884"
        "3540609675072447908266747442694779693271275625905162991558428024797357"
        "4982901759346087765303148354649034781511546575980607279343976514223564"
        "0043176524836922757441009738583133174559285382475104421060053214314011"
        "7522973364473780223566022418580907429985705449455910418485579485336879"
        "4924414497603893659126534852523720379098309632494051081042535487770344"
        "5463980395858540125633951625874987185632201091431400205722926440010509"
        "3246582584711387995066768479986142681783210959414386412029436944927347"
        "4706971580595343839759777247483424922550326761911990500463887324761331"
        "0988136396091996770268389625140979016110737871799986275128205839628544"
        "8769913927666124075980748550001835646336284448917221752366570009952062"
        "4962204149712559210527539395965061104591628905021355735625570373703934"
        "8820910909695034781881734185365694482016394015790222587358200297532426"
        "5417546162879457858736334381975081968887994188967026046597517253251462"
        "3321890818078661652305912780276047551141481176204280556222657307754144"
        "7127888869376447012346658682086341674914736422059261947117701176861920"
        "5983179801033987946504454913716066813837900672082251612136246193809092"
        "4513478443356853710872052811062108095307454433763079005631166295742211"
        "1836413862467267349341861130953042667089824180463305174755496912419325"
        "1370002935050517852199813133883136379309139754736867710521951665801628"
        "7099748437434503831410929872458452338993173681350826214080250663425659"
        "0921809292313538476833177034865863380783727467372920571352188148990125"
        "2466190325984708138502065278557285405816157387741358011104554497688686"
        "5380627146887426592899259966049964311538311481472475454958815714142266"
        "9537326093153052349105494817962541302844730564839637124347436522283747"
        "1772455405612172501831105819480281660524752076445635674064111164484503"
        "8173448763369825836604708909912306689518892383915078884657101284037717"
        "8574352678383086698882113832924101165030821040993430931881567739046403"
        "1529346122450232272003314073439002939704387887871055310731736070014958"
        "5522333500251958590067590419323637490608006544686130187729216645856221"
        "0685914795872822916531005613557294727480319984481336670559962068493256"
        "9957969624604178915887383644340598792882772272253056143966745756991550"
        "3066319055016695098914220915588783749746568376008737297980082909925194"
        "4399811173859963772882535307634645183188402736946444764260698711096979"
        "9714031282561628041282826041833066716213605750718096992275386578993508"
        "4386009180986933568188934783047318504875179817989069467811255178135892"
        "8289582491754088122265189877759716054142230730539765341914208711733424"
        "0920115573918239455805735698432";
    const long double result = MATCH_ARCH(factorial_of)(1754);
    char szResult[5120] = { 0 };
    snprintf(szResult, 5120, "%.0Lf", result);
    ck_assert_str_eq(value, szResult);
}
#endif /* HAVE_LONG_DOUBLE */

Suite* test_math_lib(void)
{
    Suite* suite;
    TCase* tc_utils;
    suite = suite_create("Math");
    tc_utils = tcase_create("Utils");
    tcase_add_test(tc_utils, ParseIntFromBinaryString);
    tcase_add_test(tc_utils, ParseIntFromOctalString);
    tcase_add_test(tc_utils, ParseIntFromDecimalString);
    tcase_add_test(tc_utils, ParseIntFromHexString);
    tcase_add_test(tc_utils, ParseInt64FromHexString);
    tcase_add_test(tc_utils, ParseIntValidatesInput);
    tcase_add_test(tc_utils, ParseIntValidatesBase);
    tcase_add_test(tc_utils, ParseIntChecksBounds);
    tcase_add_test(tc_utils, FactorialOfZero);
    tcase_add_test(tc_utils, FactorialOfSix);

#ifdef HAVE_LONG_DOUBLE
    tcase_add_test(tc_utils, FactorialOf170);
    tcase_add_test(tc_utils, FactorialOf1754);
#undef HAVE_LONG_DOUBLE
#endif
#ifndef VALGRIND
    tcase_add_test(tc_utils, FactorialOfChecksBounds);
    tcase_add_test(tc_utils, FactorialOfChecksBoundsGivenNegativeInput);
    tcase_add_test(tc_utils, FactorialOf64ChecksBoundsGivenNegativeInput);
#endif
    suite_add_tcase(suite, tc_utils);
    return suite;
}
